
## 魔术方法

### 临时操作之后恢复

```python
class ModifierSilencer:
    def __init__(self, obj):
        self.obj = obj

    def __enter__(self):
        # 记录状态并关闭修改器
        self.states = [m.show_viewport for m in self.obj.modifiers]
        for m in self.obj.modifiers:
            m.show_viewport = False
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        # 无论脚本是否报错，离开时都恢复修改器状态
        for m, s in zip(self.obj.modifiers, self.states):
            m.show_viewport = s

# 使用方法：
with ModifierSilencer(bpy.context.object):
    # 这里做一些重负载运算，不用担心修改器干扰速度
    pass
```